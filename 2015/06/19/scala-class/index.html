<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Scala中的类 - JavaChen Blog - Ramblings of a coder</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="JavaChen" /><meta name="description" content="阅读《Programming in Scala》，整理Scala类、继承、重载相关的一些知识点。" /><meta name="keywords" content="Java, Hadoop, Docker" />


<meta name="baidu-site-verification" content="OMsbiDfo1G" />



<meta name="generator" content="Hugo 0.58.3 with theme even" />


<link rel="canonical" href="http://localhost:1313/2015/06/19/scala-class/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.5d87ca31.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/custom.css">


<meta property="og:title" content="Scala中的类" />
<meta property="og:description" content="阅读《Programming in Scala》，整理Scala类、继承、重载相关的一些知识点。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2015/06/19/scala-class/" />
<meta property="article:published_time" content="2015-06-19T08:00:00+08:00" />
<meta property="article:modified_time" content="2015-06-19T08:00:00+08:00" />
<meta itemprop="name" content="Scala中的类">
<meta itemprop="description" content="阅读《Programming in Scala》，整理Scala类、继承、重载相关的一些知识点。">


<meta itemprop="datePublished" content="2015-06-19T08:00:00&#43;08:00" />
<meta itemprop="dateModified" content="2015-06-19T08:00:00&#43;08:00" />
<meta itemprop="wordCount" content="5438">



<meta itemprop="keywords" content="scala," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Scala中的类"/>
<meta name="twitter:description" content="阅读《Programming in Scala》，整理Scala类、继承、重载相关的一些知识点。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">JavaChen Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">JavaChen Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Scala中的类</h1>

      <div class="post-meta">
        <span class="post-time"> 2015-06-19 </span>
        <div class="post-category">
            <a href="/categories/scala/"> scala </a>
            </div>
          <span class="more-meta"> 约 5438 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#类">类</a></li>
<li><a href="#getter和setter">getter和setter</a></li>
<li><a href="#bean属性">Bean属性</a></li>
<li><a href="#构造器">构造器</a>
<ul>
<li><a href="#辅助构造器">辅助构造器</a></li>
<li><a href="#主构造器">主构造器</a></li>
<li><a href="#参数化字段">参数化字段</a></li>
</ul></li>
<li><a href="#嵌套类">嵌套类</a></li>
<li><a href="#抽象类">抽象类</a></li>
<li><a href="#继承">继承</a></li>
<li><a href="#重载">重载</a></li>
<li><a href="#重写">重写</a></li>
<li><a href="#构造顺序和提前定义">构造顺序和提前定义</a></li>
<li><a href="#参考文章">参考文章</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>阅读《Programming in Scala》，整理Scala类、继承、重载相关的一些知识点。</p>

<h1 id="类">类</h1>

<p>Scala使用class来定义类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Counter</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">value</span> <span class="k">=</span> <span class="mi">0</span> <span class="c1">// 必须初始化字段
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">increment</span><span class="o">()</span> <span class="o">{</span> <span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span> <span class="c1">// 方法默认公有
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">current</span><span class="o">()</span> <span class="k">=</span> <span class="n">value</span>  <span class="c1">//空括号方法
</span><span class="c1"></span><span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<blockquote>
<p>Scala中的类不能声明为public，一个Scala源文件中可以有多个类。</p>
</blockquote>

<p>类的初始化和调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">myCounter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Counter</span> <span class="c1">// 或new Counter()
</span><span class="c1"></span><span class="n">myCounter</span><span class="o">.</span><span class="n">increment</span><span class="o">()</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>Scala在遇到混合了无参数和空括号方法的情况时很大度。特别是，你可以用空括号方法重载无参数方法，并且反之亦可</strong>。你还可以在调用任何不带参数的方法时省略空的括号：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">myCounter</span><span class="o">.</span><span class="n">increment</span>

<span class="n">myCounter</span><span class="o">.</span><span class="n">current</span><span class="o">()</span>
<span class="n">myCounter</span><span class="o">.</span><span class="n">current</span></code></pre></td></tr></table>
</div>
</div>
<blockquote>
<p>原则上 Scala 的函数调用中可以省略所有的空括号，但在可能产生副作用的情况下，推荐仍然写一对空的括号。</p>
</blockquote>

<p>如果将current方法的声明改为下面这种<code>无参方法</code>的形式，则调用时不能带<code>( )</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Counter</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">value</span> <span class="k">=</span> <span class="mi">0</span> <span class="c1">// 必须初始化字段
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">increment</span><span class="o">()</span> <span class="o">{</span> <span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span> <span class="c1">// 方法默认公有
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">current</span> <span class="k">=</span> <span class="n">value</span> <span class="c1">//无参方法
</span><span class="c1"></span><span class="o">}</span>

<span class="k">val</span> <span class="n">myCounter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Counter</span> 

<span class="n">myCounter</span><span class="o">.</span><span class="n">current</span><span class="o">()</span>  <span class="c1">// 调用必须是myCounter.current这种风格
</span><span class="c1"></span><span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Int</span> <span class="kt">does</span> <span class="kt">not</span> <span class="kt">take</span> <span class="kt">parameters</span>
              <span class="n">myCounter</span><span class="o">.</span><span class="n">current</span><span class="o">()</span></code></pre></td></tr></table>
</div>
</div>
<p>我们还可以选择把current作为字段而不是方法来实现，只要简单地在每个实现里把 def 修改成 val 即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Counter</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">value</span> <span class="k">=</span> <span class="mi">0</span> <span class="c1">// 必须初始化字段
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">increment</span><span class="o">()</span> <span class="o">{</span> <span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span> <span class="c1">// 方法默认公有
</span><span class="c1"></span>  <span class="k">val</span> <span class="n">current</span> <span class="k">=</span> <span class="n">value</span> 
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>唯一的差别是字段的访问或许稍微比方法调用要快，因为字段值在类被初始化的时候被预计算，而方法调用在每次调用的时候都要计算。换句话说，字 段在每个 Element 对象上需要更多的内存空间。</p>

<h1 id="getter和setter">getter和setter</h1>

<p>Scala对每个字段都提供了getter和setter方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Person</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>上面例子中，getter和setter分别叫做<code>age</code>和<code>age_=</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">println</span><span class="o">(</span><span class="n">fred</span><span class="o">.</span><span class="n">age</span><span class="o">)</span> <span class="c1">// 调用方法fred.age()
</span><span class="c1"></span><span class="n">fred</span><span class="o">.</span><span class="n">age</span> <span class="k">=</span> <span class="mi">21</span> <span class="o">//</span> <span class="n">调用方法fred</span><span class="o">.</span><span class="n">age_=</span><span class="o">(</span><span class="mi">21</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<p>将这个简单的Person编译后，使用<code>javap</code>查看生成的字节码，可以验证这一点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// -private选项说明显示所有的类和成员
</span><span class="c1"></span><span class="n">javap</span> <span class="o">-</span><span class="k">private</span> <span class="nc">Person</span><span class="o">.</span><span class="n">class</span></code></pre></td></tr></table>
</div>
</div>
<p>Person字节码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">public</span> <span class="k">class</span> <span class="nc">Person</span> <span class="n">implements</span> <span class="n">scala</span><span class="o">.</span><span class="nc">ScalaObject</span> <span class="o">{</span>
  <span class="k">private</span> <span class="n">int</span> <span class="n">age</span><span class="o">;</span>
  <span class="n">public</span> <span class="n">int</span> <span class="n">age</span><span class="o">();</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">age_$eq</span><span class="o">(</span><span class="n">int</span><span class="o">);</span> <span class="c1">// =号被翻译成了$eq
</span><span class="c1"></span>  <span class="n">public</span> <span class="nc">Person</span><span class="o">();</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Scala中，字段和getter/setter间的关系，还有其他几种情况。</p>

<p>使用val声明的字段，是只有getter，因为val声明的是不可变的。Scala中不能实现只有setter的字段。</p>

<p>还有种对象私有字段。Scala中，方法可以访问该类的所有对象的私有字段，这一点与Java一样。如果通过private[this]来字段来修饰，那么这个字段是对象私有的，这种情况下，不会生成getter和setter。对象私有字段，只能由当前对象的方法访问，而该类的其他对象的方法是无法访问的。</p>

<p>接下来是一种与private[this]相似的访问控制。Scala中可以使用private[class-name]来指定可以访问该字段的类，class-name必须是当前定义的类，或者是当前定义的类的外部类。这种情况会生成getter和setter方法。</p>

<p>没有初始值的字段即是<code>抽象字段</code>，关于<code>抽象类</code>的说明，后面再讨论。根据是val声明还是var声明，会生成相应的抽象的setter/getter，但是不生成字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Person</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>查看编译后的字节码，可以得知，JVM类只生成了setter/getter，但没有生成字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">abstract</span> <span class="kd">class</span> <span class="nf">Person</span> <span class="kd">implements</span> <span class="nf">scala</span><span class="p">.</span><span class="na">ScalaObject</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="nf">abstract</span> <span class="kt">int</span> <span class="nf">id</span><span class="p">();</span>
  <span class="kd">public</span> <span class="nf">abstract</span> <span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">String</span> <span class="nf">name</span><span class="p">();</span>
  <span class="kd">public</span> <span class="nf">abstract</span> <span class="kt">void</span> <span class="nf">name_$eq</span><span class="p">(</span><span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">String</span><span class="p">);</span>
  <span class="kd">public</span> <span class="nf">Person</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="bean属性">Bean属性</h1>

<p>使用 <code>@BeanProperty</code> 注解来为字段生成符合JavaBeans规范的getter/setter方法。使用该注解后，将会生成4个方法：Scala的getter/setter和JavaBeans规范的getter/setter（如果是val声明，就没有setter部分了）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">scala.reflect.BeanProperty</span>
<span class="c1">// 在Scala 2.10.0之后已被废弃
</span><span class="c1">// 使用scala.beans.BeanProperty代替
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Person</span> <span class="o">{</span>
  <span class="nd">@BeanProperty</span> <span class="k">var</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">_</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="构造器">构造器</h1>

<p>在Scala中，有两种构造器，主构造器（primary constructor）和辅助构造器（auxiliary constructor）。</p>

<h2 id="辅助构造器">辅助构造器</h2>

<p><code>辅助构造器</code>与Java构造器很相似，但有两点不同：</p>

<ul>
<li>名字是this（Java中构造器名称与类名相同）</li>

<li><p>辅助构造器必须以对已经定义的辅助构造器或主构造器的调用开始</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Person</span> <span class="o">{</span>
<span class="k">private</span> <span class="k">var</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&#34;&#34;</span>
<span class="k">private</span> <span class="k">var</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">0</span>
 
<span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
<span class="k">this</span><span class="o">()</span> <span class="c1">// 调用主构造器
</span><span class="c1"></span><span class="k">this</span><span class="o">.</span><span class="n">name</span> <span class="k">=</span> <span class="n">name</span>
<span class="o">}</span>
 
<span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
<span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>  <span class="c1">// 调用辅助构造器
</span><span class="c1"></span><span class="k">this</span><span class="o">.</span><span class="n">age</span> <span class="k">=</span> <span class="n">age</span>
<span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>

<p>调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">p1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span> <span class="c1">// 主构造器
</span><span class="c1"></span><span class="k">val</span> <span class="n">p2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&#34;Fred&#34;</span><span class="o">)</span>  <span class="c1">// 第一个辅助构造器
</span><span class="c1"></span><span class="k">val</span> <span class="n">p3</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&#34;Fred&#34;</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span> <span class="o">//</span> <span class="n">第二个辅助构造器</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="主构造器">主构造器</h2>

<p>在scala中每个类都有主构造器，主构造器并不是以<code>this</code>方法定义，而是与类定义交织在一起。</p>

<p>1、主构造器参数直接放在类名之后，指的是<code>()</code>中的参数，主构造器参数会被编译成字段，其值被初始化成构造时传入的参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">name</span><span class="k">:</span><span class="kt">String</span> <span class="o">=</span><span class="n">a</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>2、主构造器会执行类定义中的所有语句，这里是是<code>{}</code>中的语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Person</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">printNum</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">println</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">printNum</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>3、如果主构造器参数不带val或var，那么会根据是否被方法使用来决定。如果不带val或var的参数被方法使用了，它会变为对象私有字段；如果没有被方法使用，则被当成一个普通的参数，不升级成字段。这部分说明请看<code>参数化字段</code>。</p>

<p>4、可以将主构造器变为私有的，将private关键字放在圆括号前：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Person</span> <span class="k">private</span><span class="o">(</span><span class="k">var</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span><span class="k">val</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">){</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>编译之后：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">//javap
</span><span class="c1"></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Person</span> <span class="o">{</span>
  <span class="k">private</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="k">private</span> <span class="k">final</span> <span class="n">int</span> <span class="n">age</span><span class="o">;</span>
  <span class="n">public</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span> <span class="n">name</span><span class="o">();</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">name_$eq</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span><span class="o">);</span>
  <span class="n">public</span> <span class="n">int</span> <span class="n">age</span><span class="o">();</span>
  
  <span class="c1">//注意私有构造方法
</span><span class="c1"></span>  <span class="k">private</span> <span class="nc">Person</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span><span class="o">,</span> <span class="n">int</span><span class="o">);</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="参数化字段">参数化字段</h2>

<p>1、构造参数不带var或val，被类中函数使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">name</span><span class="k">:</span><span class="kt">String</span> <span class="o">=</span><span class="n">a</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>则构造参数被升格为私有字段，效果类似<code>private[this] val</code>，反编译该类为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">Person</span> <span class="nf">extends</span> <span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">Object</span><span class="p">{</span>
    <span class="c1">//私有final
</span><span class="c1"></span>    <span class="kd">private</span> <span class="nf">final</span> <span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">String</span> <span class="nf">a</span><span class="p">;</span>

    <span class="kd">public</span> <span class="nf">static</span> <span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">String</span> <span class="nf">$lessinit$greater$default$1</span><span class="p">();</span>

    <span class="c1">//函数
</span><span class="c1"></span>    <span class="kd">public</span> <span class="nf">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">String</span> <span class="n">name</span><span class="p">();</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="p">(</span><span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">String</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>2、构造参数不带var或val，未在类中使用，则该参数为普通参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>反编译为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">Person</span> <span class="nf">extends</span> <span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">Object</span><span class="p">{</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="p">(</span><span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">String</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>3、构造参数带var或val。Person类的定义中有一个构造参数a，并在name方法中被使用，如果你想避免这种参数和方法混合在一起的定义方式，你可以使用<code>参数化字段</code>来定义类，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// 请注意小括号 
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Person</span><span class="o">(</span> <span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>

<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这是在同一时间使用相同的名称定义参数和属性的一个<code>简写</code>方式。尤其特别的是，类 Person 现在拥有一个<code>可以从类外部访问的不能重新赋值</code>的属性name。</p>

<p>同样也可以使用var前缀类参数，这种情况下相应的字段将能重新被赋值。最终，还有可能添加 如private、protected、或override这类的修饰符到这些参数化字段上，就好象你可以在其他类成员上做的事情。</p>

<h1 id="嵌套类">嵌套类</h1>

<p>在Scala中，几乎可以在任何的语法结构中内嵌任何语法结构。可以类中定义类，也可以在方法中定义方法。</p>

<p>Scala中每个实例都有自己的内部类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>
 
<span class="k">class</span> <span class="nc">NetWork</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Member</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">}</span>
 
  <span class="k">private</span> <span class="k">val</span> <span class="n">members</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Member</span><span class="o">]</span>
 
  <span class="k">def</span> <span class="n">join</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Member</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">members</span> <span class="o">+=</span> <span class="n">m</span>
    <span class="n">m</span>
  <span class="o">}</span>
<span class="o">}</span>
 
<span class="k">val</span> <span class="n">chatter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NetWork</span>
<span class="k">val</span> <span class="n">myFace</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NetWork</span>

<span class="k">val</span> <span class="n">m1</span><span class="k">=new</span> <span class="n">chatter</span><span class="o">.</span><span class="nc">Member</span><span class="o">(</span><span class="s">&#34;m1&#34;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m2</span><span class="k">=new</span> <span class="n">chatter</span><span class="o">.</span><span class="nc">Member</span><span class="o">(</span><span class="s">&#34;m2&#34;</span><span class="o">)</span>

<span class="n">chatter</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">m1</span><span class="o">)</span>
<span class="n">chatter</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">m2</span><span class="o">)</span>

<span class="k">val</span> <span class="n">m3</span><span class="k">=new</span> <span class="n">myFace</span><span class="o">.</span><span class="nc">Member</span><span class="o">(</span><span class="s">&#34;m3&#34;</span><span class="o">)</span>
<span class="n">chatter</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">m3</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<p>往chatter中加入m3时，会出现编译错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></pre></td>
<td class="lntd">
<pre class="chroma">&lt;console&gt;:14: error: type mismatch;
 found   : myFace.Member
 required: chatter.Member
              chatter.join(m3)</pre></td></tr></table>
</div>
</div>
<p>这是因为，chatter.Member类和myFace.Member类是不同的两个类。这一点与Java中内部类是不同的。</p>

<p>如果想产生类似Java中的内部类特性，可以将Member声明到Network的外部，或者使用<code>类型投影</code>，这里是将内部类中的Member换成NetWork#Member，代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>
 
<span class="k">class</span> <span class="nc">NetWork</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Member</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">}</span>
 
  <span class="k">private</span> <span class="k">val</span> <span class="n">members</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">NetWork</span><span class="k">#</span><span class="kt">Member</span><span class="o">]</span>
 
  <span class="k">def</span> <span class="n">join</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">NetWork</span><span class="k">#</span><span class="kt">Member</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">members</span> <span class="o">+=</span> <span class="n">m</span>
    <span class="n">m</span>
  <span class="o">}</span>
<span class="o">}</span>
 
<span class="k">val</span> <span class="n">chatter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NetWork</span>
<span class="k">val</span> <span class="n">myFace</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NetWork</span>

<span class="k">val</span> <span class="n">m1</span><span class="k">=new</span> <span class="n">chatter</span><span class="o">.</span><span class="nc">Member</span><span class="o">(</span><span class="s">&#34;m1&#34;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m2</span><span class="k">=new</span> <span class="n">chatter</span><span class="o">.</span><span class="nc">Member</span><span class="o">(</span><span class="s">&#34;m2&#34;</span><span class="o">)</span>

<span class="n">chatter</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">m1</span><span class="o">)</span>
<span class="n">chatter</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">m2</span><span class="o">)</span>

<span class="k">val</span> <span class="n">m3</span><span class="k">=new</span> <span class="n">myFace</span><span class="o">.</span><span class="nc">Member</span><span class="o">(</span><span class="s">&#34;m3&#34;</span><span class="o">)</span>
<span class="n">chatter</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">m3</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<p>与Java中一样，如果需要在内部类中使用外部类的引用，使用 <code>外部类名.class</code> 的语法即可。不过Scala中有一个为这种情况服务的语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">NetWork</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span> <span class="n">outer</span> <span class="k">=&gt;</span>
  <span class="k">class</span> <span class="nc">Member</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">description</span> <span class="k">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#34; inside &#34;</span> <span class="o">+</span> <span class="n">outer</span><span class="o">.</span><span class="n">name</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">work</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NetWork</span><span class="o">(</span><span class="s">&#34;work&#34;</span><span class="o">)</span>
<span class="n">work</span><span class="o">.</span><span class="n">name</span>
<span class="c1">//work
</span><span class="c1"></span>
<span class="k">val</span> <span class="n">m1</span><span class="k">=new</span> <span class="n">work</span><span class="o">.</span><span class="nc">Member</span><span class="o">(</span><span class="s">&#34;m1&#34;</span><span class="o">)</span>
<span class="n">m1</span><span class="o">.</span><span class="n">description</span>
<span class="o">//</span><span class="n">m1</span> <span class="n">inside</span> <span class="n">work</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="抽象类">抽象类</h1>

<p>和Java一样，Scala用<code>abstract</code>修饰抽象类，抽象类没有具体实例方法。具有抽象成员的类本身必须被声明为抽象的。抽象类定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">}</span> </code></pre></td></tr></table>
</div>
</div>
<p>请注意类 Element 的 contents 方法并没带有 abstract 修饰符，如果方法没有实现，也就是说没有等号或方法体，它就是抽象的。类 Element <code>声明</code>了抽象方法 contents，但当前没有<code>定义</code>具体方法。</p>

<p>抽象类不能实例化，否则会得到编译器错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Element</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Element</span> <span class="kt">is</span> <span class="kt">abstract</span><span class="o">;</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">instantiated</span>
              <span class="k">new</span> <span class="nc">Element</span></code></pre></td></tr></table>
</div>
</div>
<p>我们可以向 Element 添加显示宽度和高度的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>
  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>请注意 Element 的三个方法没一个有参数列表，甚至连个空列表都没有。这种<code>无参数方法</code>在Scala里是非常普通的，带有空括号的方法，被称为<code>空括号方法</code>。</p>

<h1 id="继承">继承</h1>

<p>继承一个抽象类使用<code>extends</code>关键字，如果你省略 extends，Scala 编译器隐式地假设你的类扩展自 <code>scala.AnyRef</code>，在 Java 平台上与 java.lang.Object 一致。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>如果将类声明为final的，则这个类不能被继承。如果将类的方法和字段声明为final，则它们不能被重写。</p>

<p>子类继承超类中所有<code>非私有</code>的成员，如果子类中的成员与超类中成员具有相同名称和参数，则成为<code>重载</code>；如果子类中的成员是具体的而超类中的是抽象的，我们还可以说子类实现了超类中的成员。</p>

<p>上面例子中，ArrayElement类的contents方法重载或者说实现了超类的contents方法，并继承了width和height方法。我们可以实例一个ArrayElement对象，然后调用方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ae</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">,</span> <span class="s">&#34;world&#34;</span><span class="o">))</span>
<span class="n">ae</span><span class="k">:</span> <span class="kt">ArrayElement</span> <span class="o">=</span> <span class="nc">ArrayElement</span><span class="nd">@d94e60</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ae</span><span class="o">.</span><span class="n">width</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span></code></pre></td></tr></table>
</div>
</div>
<p>上面ae变量的类型是ArrayElement，其实我们也可以将其声明为超类类型，这叫做<code>子类型化</code>：是指子类的值可以被用在需要其超类的值的任何地方。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">))</span></code></pre></td></tr></table>
</div>
</div>
<p>这样的话，e变量是声明为Element类型，但是是初始化为ArrayElement类型。这个涉及到<code>多态</code>的概念。</p>

<p>如果子类要调用超类的构造器，则需要这样定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">height</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>LineElement类继承自ArrayElement，并且LineElement类的构造器中传入了一个参数s，LineElement类想要调用超类的构造器，需要把要传递的参数或参数列表放在超类名之后的括号里即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="o">...</span> <span class="k">extends</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">...</span></code></pre></td></tr></table>
</div>
</div>
<p>这样，就完成了子类调用父类的构造器进行初始化父类。</p>

<h1 id="重载">重载</h1>

<p>统一访问原则只是 Scala 在对待字段和方法方面比 Java 更统一的一个方面；另一个差异是 Scala 里，字段和方法属于相同的命名空间。这使得字段重载无参数方法成为可能。比如说，你可以改变类 ArrayElement 中 contents 的实现，从一个方法变为一个字段，而无需修改类 Element 中 contents 的抽象方法定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Scala里禁止在同一个类里用同样的名称定义字段和方法</code>，例如，下面的代码在Scala中无法通过编译：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">WontCompile</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">f</span> <span class="k">=</span> <span class="mi">0</span>  <span class="c1">// 编译不过，因为字段和方法重名 
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">f</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>通常情况下，Scala 仅为定义准备了两个命名空间：值(字段、方法、包还有单例对象)、类型(类和特质名)，而 Java 有四个：字 段、方法、类型和包。</p>

<p>Scala把字段和方法放进同一个命名空间，这样你就可以使用val重载无参数的方法。</p>

<h1 id="重写">重写</h1>

<p>在Scala中<code>重写一个非抽象方法必须使用override修饰符</code>，<strong>重写超类的抽象方法时，不需要使用override关键字</strong>。调用超类的方法就如Java一样，使用<code>super</code>关键字。</p>

<p>请注意 LineElement 里 width 和 height 的定义带着 <code>override</code> 修饰符。<code>Scala里所有重载了父类具体成员的成员都需要这样的修饰符</code>。如果成员实现的 是同名的抽象成员则这个修饰符是可选的。而如果成员并未重载或实现什么其它基类里的成员则禁用这个修饰符。由于类 LineElement 的 height 和 width 重载了类 Element 的具体成员定义，override 是需要的。</p>

<p>这条规则给编译器提供了有用的信息来帮助避免某些难以捕捉的错误并使得系统的改进更加安全。</p>

<h1 id="构造顺序和提前定义">构造顺序和提前定义</h1>

<p>现有如下的类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Creature</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">range</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">range</span><span class="o">)</span>
<span class="o">}</span>
 
<span class="k">class</span> <span class="nc">Ant</span> <span class="k">extends</span> <span class="nc">Creature</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">range</span> <span class="k">=</span> <span class="mi">2</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在构造时，发生的过程如下：</p>

<ul>
<li>Ant构造器在构造自己之前，调用超类构造器；</li>
<li>Creature的构造器将range字段设为10；</li>
<li>Creature的构造器初始化env数组，调用range字段的getter；</li>
<li>range的getter被Ant类重写了，返回的Ant类中的range，但是Ant类还未初始化，所以返回了0；</li>
<li>env被设置成长度为0的数组</li>
<li>Ant构造器继续执行，将range字段设为2。</li>
</ul>

<p>在Java中也会出现碰见相似的问题，被调用的方法被子类所重写，有可能结果不是预期的。在构造器中，不应该依赖val的值。（只能重写超类抽象的var声明字段，所以没有这个问题；如果是def，也一样会出现这种问题。）</p>

<p>这个问题的根本原因来自于Java语言的设计决定——允许在超类的构造方法中调用子类的方法。而在C++中，构造前后会更改指向虚函数的指针，所以不会出现这类问题。</p>

<p>这个问题有几种解决方法：</p>

<ul>
<li>将val声明为<code>final</code>，安全但不灵活；</li>
<li>在超类中将val声明为<code>lazy</code>，安全但不高效；</li>
<li>使用提前定义语法。</li>
</ul>

<p><code>提前定义语法</code>是将需要提前定义的成员放在extends关键字后的一个语法块中，还需要使用<code>with</code>关键字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Ant</span> <span class="k">extends</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">range</span> <span class="k">=</span> <span class="mi">2</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">Creature</span></code></pre></td></tr></table>
</div>
</div>
<p>提前定义的等号右侧只能引用之前已经有的提前定义，不能出现类中其他的成员（因为都还没初始化呢）。</p>

<blockquote>
<p>使用<code>-Xcheckinit</code>编译器标志来调试构造顺序问题。这个标志会在有未初始化的字段被访问时抛出异常。</p>
</blockquote>

<h1 id="参考文章">参考文章</h1>

<ul>
<li><a href="http://nerd-is.in/images-08/scala-learning-classes/">Scala学习——类</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">JavaChen</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2015-06-19
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechatpay.jpg">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay.jpg">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/scala/">scala</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2015/06/19/scala-object/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Scala中的对象</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2015/06/18/simplify-code-using-scala-higher-order-function/">
            <span class="next-text nav-default">使用Scala高价函数简化代码</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="javachen/javachen.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:junecloud@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/javachen" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/chenzhijun" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://space.bilibili.com/287563020/" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2009 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">JavaChen</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.20b54c22.min.js"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?7eaf37274cf8796df56903a88389e82f";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>
